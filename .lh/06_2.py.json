{
    "sourceFile": "06_2.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 31,
            "patches": [
                {
                    "date": 1733602139611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733602161107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n     GUARD = '^'\n     WALL = '#'\n     FREE = '.'\n     VISITED = 'x'\n-    NORTH = 'N'\n+    NORTH = '^'\n     EAST = 'E'\n     SOUTH = 'S'\n     WEST = 'W'\n \n"
                },
                {
                    "date": 1733602166255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,10 +15,10 @@\n     WALL = '#'\n     FREE = '.'\n     VISITED = 'x'\n     NORTH = '^'\n-    EAST = 'E'\n-    SOUTH = 'S'\n+    EAST = '>'\n+    SOUTH = ''\n     WEST = 'W'\n \n # Movement function based on current direction\n def move(row, col, direction):\n"
                },
                {
                    "date": 1733602191522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,10 @@\n     FREE = '.'\n     VISITED = 'x'\n     NORTH = '^'\n     EAST = '>'\n-    SOUTH = ''\n-    WEST = 'W'\n+    SOUTH = 'v'\n+    WEST = '<'\n \n # Movement function based on current direction\n def move(row, col, direction):\n     match direction:\n@@ -83,9 +83,9 @@\n             for col in range(max_col + 1):\n                 row_str += field.get((row, col), Symbols.FREE)\n             print(row_str)\n         \n-        time.sleep(0.2)\n+        time.sleep(0.02)\n         \n         # Determine the next position\n         new_row, new_col = move(guard_row, guard_col, facing)\n         new_pos = (new_row, new_col)\n"
                },
                {
                    "date": 1733602213919,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,9 +110,9 @@\n                        (facing == Direction.EAST and direction == Symbols.SOUTH) or \\\n                        (facing == Direction.SOUTH and direction == Symbols.WEST):\n                         loop_count += 1\n                         print(\"Guard is stuck in a loop!\")\n-                        return loop_count\n+                        break\n                 case _:\n                     print('bug field = ' + str(field[new_pos]))\n                     return loop_count  # Exit on unexpected symbol\n         \n"
                },
                {
                    "date": 1733602555009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n         # Overwrite the current cell with the facing direction\n         if current_symbol == Symbols.FREE or current_symbol == Symbols.VISITED:\n             field[current_pos] = getattr(Symbols, facing.name)\n         else:\n-            field[current_pos] = getattr(Symbols, facing.name)\n+            field[current_pos].append(getattr(Symbols, facing.name))\n         \n         # Clear the console\n         os.system('cls' if os.name == 'nt' else 'clear')\n         \n"
                },
                {
                    "date": 1733602576921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,14 @@\n         # Print the field\n         for row in range(max_row + 1):\n             row_str = ''\n             for col in range(max_col + 1):\n-                row_str += field.get((row, col), Symbols.FREE)\n+                cell_symbols = field.get((row, col), [Symbols.FREE])\n+                if Symbols.FREE in cell_symbols:\n+                    row_str += Symbols.FREE\n+                else:\n+                    # Display the most recent direction symbol\n+                    row_str += cell_symbols[-1]\n             print(row_str)\n         \n         time.sleep(0.02)\n         \n"
                },
                {
                    "date": 1733602587460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,14 +80,9 @@\n         # Print the field\n         for row in range(max_row + 1):\n             row_str = ''\n             for col in range(max_col + 1):\n-                cell_symbols = field.get((row, col), [Symbols.FREE])\n-                if Symbols.FREE in cell_symbols:\n-                    row_str += Symbols.FREE\n-                else:\n-                    # Display the most recent direction symbol\n-                    row_str += cell_symbols[-1]\n+                row_str += field.get((row, col), Symbols.FREE)\n             print(row_str)\n         \n         time.sleep(0.02)\n         \n"
                },
                {
                    "date": 1733602624583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,10 +32,10 @@\n         case Direction.EAST:\n             return row, col + 1\n \n # Boundary check to ensure the guard stays within the field\n-def in_bounds(row, col, field):\n-    return (row, col) in field\n+def in_bounds(row, col, field, max_row, max_col):\n+    return 0 <= row <= max_row and 0 <= col <= max_col and (row, col) in field\n \n # Function to turn the guard right\n def turn_right(facing):\n     return Direction((facing + 1) % 4)\n@@ -80,9 +80,14 @@\n         # Print the field\n         for row in range(max_row + 1):\n             row_str = ''\n             for col in range(max_col + 1):\n-                row_str += field.get((row, col), Symbols.FREE)\n+                cell_symbols = field.get((row, col), [Symbols.FREE])\n+                if Symbols.FREE in cell_symbols:\n+                    row_str += Symbols.FREE\n+                else:\n+                    # Display the most recent direction symbol\n+                    row_str += cell_symbols[-1]\n             print(row_str)\n         \n         time.sleep(0.02)\n         \n"
                },
                {
                    "date": 1733602648555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n         # Determine the next position\n         new_row, new_col = move(guard_row, guard_col, facing)\n         new_pos = (new_row, new_col)\n         \n-        if not in_bounds(new_row, new_col, field):\n+        if not in_bounds(new_row, new_col, field, max_row, max_col):\n             print(\"Guard has moved out of bounds.\")\n             break\n         \n         split = field[new_pos].split(',')\n"
                },
                {
                    "date": 1733602654398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,9 +98,9 @@\n         if not in_bounds(new_row, new_col, field, max_row, max_col):\n             print(\"Guard has moved out of bounds.\")\n             break\n         \n-        split = field[new_pos].split(',')\n+        split = field[new_pos]\n         \n         for symbol in split:\n             match symbol:\n                 case Symbols.WALL:\n"
                },
                {
                    "date": 1733602675098,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,16 +63,17 @@\n \n # Animate Part 2 using terminal output with hashmap\n def animate_part_2(guard_row, guard_col, facing, field, max_row, max_col):\n     loop_count = 0\n-    while in_bounds(guard_row, guard_col, field):\n+    while in_bounds(guard_row, guard_col, field, max_row, max_col):\n         current_pos = (guard_row, guard_col)\n-        current_symbol = field.get(current_pos, Symbols.FREE)\n-        \n-        # Overwrite the current cell with the facing direction\n-        if current_symbol == Symbols.FREE or current_symbol == Symbols.VISITED:\n-            field[current_pos] = getattr(Symbols, facing.name)\n+        current_symbols = field.get(current_pos, [Symbols.FREE])\n+\n+        # Overwrite the current cell with the current facing direction\n+        if Symbols.FREE in current_symbols:\n+            field[current_pos] = [getattr(Symbols, facing.name)]\n         else:\n+            # Append the current facing direction to the list of symbols\n             field[current_pos].append(getattr(Symbols, facing.name))\n         \n         # Clear the console\n         os.system('cls' if os.name == 'nt' else 'clear')\n@@ -88,9 +89,9 @@\n                     # Display the most recent direction symbol\n                     row_str += cell_symbols[-1]\n             print(row_str)\n         \n-        time.sleep(0.02)\n+        time.sleep(0.2)\n         \n         # Determine the next position\n         new_row, new_col = move(guard_row, guard_col, facing)\n         new_pos = (new_row, new_col)\n@@ -115,18 +116,20 @@\n                        (facing == Direction.EAST and direction == Symbols.SOUTH) or \\\n                        (facing == Direction.SOUTH and direction == Symbols.WEST):\n                         loop_count += 1\n                         print(\"Guard is stuck in a loop!\")\n-                        break\n+                        return loop_count\n                 case _:\n                     print('bug field = ' + str(field[new_pos]))\n                     return loop_count  # Exit on unexpected symbol\n         \n         # Move the guard to the new position if no wall was encountered\n         if Symbols.WALL not in split:\n             guard_row, guard_col = new_row, new_col\n-            field[new_pos] = Symbols.VISITED  # Mark as visited\n-\n+            # Mark as visited (optional)\n+            if Symbols.VISITED not in field[new_pos]:\n+                field[new_pos].append(Symbols.VISITED)\n+    \n     return loop_count\n \n # Main Execution\n if __name__ == \"__main__\":\n"
                },
                {
                    "date": 1733602680652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,9 +116,9 @@\n                        (facing == Direction.EAST and direction == Symbols.SOUTH) or \\\n                        (facing == Direction.SOUTH and direction == Symbols.WEST):\n                         loop_count += 1\n                         print(\"Guard is stuck in a loop!\")\n-                        return loop_count\n+                        b\n                 case _:\n                     print('bug field = ' + str(field[new_pos]))\n                     return loop_count  # Exit on unexpected symbol\n         \n"
                },
                {
                    "date": 1733602906246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,33 +47,38 @@\n     max_col = 0\n     with open(file_path) as file:\n         for row_idx, line in enumerate(file):\n             for col_idx, char in enumerate(line.rstrip('\\n')):\n-                field[(row_idx, col_idx)] = char\n+                if char == Symbols.FREE:\n+                    field[(row_idx, col_idx)] = []\n+                else:\n+                    field[(row_idx, col_idx)] = [char]\n                 max_col = max(max_col, col_idx)\n             max_row = max(max_row, row_idx)\n     return field, max_row, max_col\n \n # Function to find the guard's initial position\n def find_guard(field):\n-    for (row, col), symbol in field.items():\n-        if symbol == Symbols.GUARD:\n+    for (row, col), symbols in field.items():\n+        if Symbols.GUARD in symbols:\n             return row, col\n     # If guard not found, set default position\n     return 0, 0\n \n # Animate Part 2 using terminal output with hashmap\n def animate_part_2(guard_row, guard_col, facing, field, max_row, max_col):\n     loop_count = 0\n+    detected_loops = set()  # To track unique loop states\n+    visited_states = {}     # To track when a state was first visited\n+\n     while in_bounds(guard_row, guard_col, field, max_row, max_col):\n         current_pos = (guard_row, guard_col)\n-        current_symbols = field.get(current_pos, [Symbols.FREE])\n+        current_symbols = field.get(current_pos, [])\n \n         # Overwrite the current cell with the current facing direction\n-        if Symbols.FREE in current_symbols:\n+        if not current_symbols or Symbols.FREE in current_symbols:\n             field[current_pos] = [getattr(Symbols, facing.name)]\n         else:\n-            # Append the current facing direction to the list of symbols\n             field[current_pos].append(getattr(Symbols, facing.name))\n         \n         # Clear the console\n         os.system('cls' if os.name == 'nt' else 'clear')\n@@ -81,10 +86,10 @@\n         # Print the field\n         for row in range(max_row + 1):\n             row_str = ''\n             for col in range(max_col + 1):\n-                cell_symbols = field.get((row, col), [Symbols.FREE])\n-                if Symbols.FREE in cell_symbols:\n+                cell_symbols = field.get((row, col), [])\n+                if not cell_symbols:\n                     row_str += Symbols.FREE\n                 else:\n                     # Display the most recent direction symbol\n                     row_str += cell_symbols[-1]\n@@ -109,16 +114,18 @@\n                     break  # Stop processing symbols after hitting a wall\n                 case Symbols.FREE:\n                     pass  # Continue moving forward\n                 case direction if direction in [Symbols.NORTH, Symbols.EAST, Symbols.SOUTH, Symbols.WEST]:\n-                    # Handle loop detection based on current facing and symbol\n-                    if (facing == Direction.WEST and direction == Symbols.NORTH) or \\\n-                       (facing == Direction.NORTH and direction == Symbols.EAST) or \\\n-                       (facing == Direction.EAST and direction == Symbols.SOUTH) or \\\n-                       (facing == Direction.SOUTH and direction == Symbols.WEST):\n-                        loop_count += 1\n-                        print(\"Guard is stuck in a loop!\")\n-                        b\n+                    # Create a unique state identifier\n+                    state = (new_pos, facing)\n+                    if state in visited_states:\n+                        # Loop detected\n+                        if state not in detected_loops:\n+                            loop_count += 1\n+                            print(f\"Guard has entered a loop #{loop_count} at position {new_pos} facing {facing.name}.\")\n+                            detected_loops.add(state)\n+                    else:\n+                        visited_states[state] = True\n                 case _:\n                     print('bug field = ' + str(field[new_pos]))\n                     return loop_count  # Exit on unexpected symbol\n         \n@@ -142,5 +149,5 @@\n     facing = Direction.NORTH  # Initialize facing direction (adjust as needed)\n     \n     # Run the simulation\n     loop_count = animate_part_2(guard_row, guard_col, facing, field, max_row, max_col)\n-    print(f\"Guard loop count: {loop_count}\")\n\\ No newline at end of file\n+    print(f\"Total loops detected: {loop_count}\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733602921556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,9 +94,9 @@\n                     # Display the most recent direction symbol\n                     row_str += cell_symbols[-1]\n             print(row_str)\n         \n-        time.sleep(0.2)\n+        time.sleep(0.01)\n         \n         # Determine the next position\n         new_row, new_col = move(guard_row, guard_col, facing)\n         new_pos = (new_row, new_col)\n"
                },
                {
                    "date": 1733603375480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,8 @@\n class Symbols:\n     GUARD = '^'\n     WALL = '#'\n     FREE = '.'\n-    VISITED = 'x'\n     NORTH = '^'\n     EAST = '>'\n     SOUTH = 'v'\n     WEST = '<'\n"
                },
                {
                    "date": 1733603387864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,11 +130,8 @@\n         \n         # Move the guard to the new position if no wall was encountered\n         if Symbols.WALL not in split:\n             guard_row, guard_col = new_row, new_col\n-            # Mark as visited (optional)\n-            if Symbols.VISITED not in field[new_pos]:\n-                field[new_pos].append(Symbols.VISITED)\n     \n     return loop_count\n \n # Main Execution\n"
                },
                {
                    "date": 1733603499467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from enum import IntEnum\n import time\n import os\n \n-# Define Directions using IntEnum for clarity\n+# Define Directions using IntEnum for clarity and easy arithmetic\n class Direction(IntEnum):\n     NORTH = 0\n     EAST = 1\n     SOUTH = 2\n@@ -13,12 +13,13 @@\n class Symbols:\n     GUARD = '^'\n     WALL = '#'\n     FREE = '.'\n-    NORTH = '^'\n-    EAST = '>'\n-    SOUTH = 'v'\n-    WEST = '<'\n+    VISITED = 'x'\n+    NORTH = '^'  # Symbol when facing NORTH\n+    EAST = '>'   # Symbol when facing EAST\n+    SOUTH = 'v'  # Symbol when facing SOUTH\n+    WEST = '<'   # Symbol when facing WEST\n \n # Movement function based on current direction\n def move(row, col, direction):\n     match direction:\n@@ -63,14 +64,16 @@\n     # If guard not found, set default position\n     return 0, 0\n \n # Animate Part 2 using terminal output with hashmap\n-def animate_part_2(guard_row, guard_col, facing, field, max_row, max_col):\n+def animate_part_2(guard_row, guard_col, facing, field, max_row, max_col, max_steps=10000):\n     loop_count = 0\n     detected_loops = set()  # To track unique loop states\n     visited_states = {}     # To track when a state was first visited\n+    steps = 0               # Step counter to prevent infinite loops\n \n-    while in_bounds(guard_row, guard_col, field, max_row, max_col):\n+    while in_bounds(guard_row, guard_col, field, max_row, max_col) and steps < max_steps:\n+        steps += 1\n         current_pos = (guard_row, guard_col)\n         current_symbols = field.get(current_pos, [])\n \n         # Overwrite the current cell with the current facing direction\n@@ -93,9 +96,9 @@\n                     # Display the most recent direction symbol\n                     row_str += cell_symbols[-1]\n             print(row_str)\n         \n-        time.sleep(0.01)\n+        time.sleep(0.01)  # Adjust the sleep time as needed for visibility\n         \n         # Determine the next position\n         new_row, new_col = move(guard_row, guard_col, facing)\n         new_pos = (new_row, new_col)\n@@ -130,9 +133,15 @@\n         \n         # Move the guard to the new position if no wall was encountered\n         if Symbols.WALL not in split:\n             guard_row, guard_col = new_row, new_col\n+            # Mark as visited (optional)\n+            if Symbols.VISITED not in field[new_pos]:\n+                field[new_pos].append(Symbols.VISITED)\n     \n+    if steps >= max_steps:\n+        print(f\"Reached maximum steps ({max_steps}). Simulation terminated to prevent infinite loop.\")\n+    \n     return loop_count\n \n # Main Execution\n if __name__ == \"__main__\":\n"
                },
                {
                    "date": 1733603505135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,11 +133,8 @@\n         \n         # Move the guard to the new position if no wall was encountered\n         if Symbols.WALL not in split:\n             guard_row, guard_col = new_row, new_col\n-            # Mark as visited (optional)\n-            if Symbols.VISITED not in field[new_pos]:\n-                field[new_pos].append(Symbols.VISITED)\n     \n     if steps >= max_steps:\n         print(f\"Reached maximum steps ({max_steps}). Simulation terminated to prevent infinite loop.\")\n     \n"
                },
                {
                    "date": 1733603511496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,8 @@\n class Symbols:\n     GUARD = '^'\n     WALL = '#'\n     FREE = '.'\n-    VISITED = 'x'\n     NORTH = '^'  # Symbol when facing NORTH\n     EAST = '>'   # Symbol when facing EAST\n     SOUTH = 'v'  # Symbol when facing SOUTH\n     WEST = '<'   # Symbol when facing WEST\n"
                },
                {
                    "date": 1733603946417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,9 @@\n class Symbols:\n     GUARD = '^'\n     WALL = '#'\n     FREE = '.'\n+    VISITED = 'x'\n     NORTH = '^'  # Symbol when facing NORTH\n     EAST = '>'   # Symbol when facing EAST\n     SOUTH = 'v'  # Symbol when facing SOUTH\n     WEST = '<'   # Symbol when facing WEST\n@@ -132,8 +133,11 @@\n         \n         # Move the guard to the new position if no wall was encountered\n         if Symbols.WALL not in split:\n             guard_row, guard_col = new_row, new_col\n+            # Mark as visited (optional)\n+            if Symbols.VISITED not in field[new_pos]:\n+                field[new_pos].append(Symbols.VISITED)\n     \n     if steps >= max_steps:\n         print(f\"Reached maximum steps ({max_steps}). Simulation terminated to prevent infinite loop.\")\n     \n"
                },
                {
                    "date": 1733610230651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,158 +1,51 @@\n-from enum import IntEnum\n-import time\n-import os\n+from sys import stdin\n \n-# Define Directions using IntEnum for clarity and easy arithmetic\n-class Direction(IntEnum):\n-    NORTH = 0\n-    EAST = 1\n-    SOUTH = 2\n-    WEST = 3\n+grid = []\n+startpos = ()\n+for line in stdin:\n+    col = []\n+    for x in line.strip():\n+        if x == \"^\":\n+            startpos = (line.index(x), len(grid))\n+        col.append(x)\n+    grid.append(col)\n \n-# Define Symbols for representation\n-class Symbols:\n-    GUARD = '^'\n-    WALL = '#'\n-    FREE = '.'\n-    VISITED = 'x'\n-    NORTH = '^'  # Symbol when facing NORTH\n-    EAST = '>'   # Symbol when facing EAST\n-    SOUTH = 'v'  # Symbol when facing SOUTH\n-    WEST = '<'   # Symbol when facing WEST\n+dirs = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n \n-# Movement function based on current direction\n-def move(row, col, direction):\n-    match direction:\n-        case Direction.NORTH:\n-            return row - 1, col\n-        case Direction.SOUTH:\n-            return row + 1, col\n-        case Direction.WEST:\n-            return row, col - 1\n-        case Direction.EAST:\n-            return row, col + 1\n+def check_loop(new_grid):\n+    visited = set()\n+    k = 0\n+    nX = startpos[0] + dirs[k][0]\n+    nY = startpos[1] + dirs[k][1]\n+    while True:\n+        if new_grid[nY][nX] == \"#\":\n+            nX -= dirs[k][0]\n+            nY -= dirs[k][1]\n \n-# Boundary check to ensure the guard stays within the field\n-def in_bounds(row, col, field, max_row, max_col):\n-    return 0 <= row <= max_row and 0 <= col <= max_col and (row, col) in field\n+            k += 1\n+            if k == 4:\n+                k = 0\n \n-# Function to turn the guard right\n-def turn_right(facing):\n-    return Direction((facing + 1) % 4)\n+        if (nX, nY, k) in visited:\n+            return True\n+    \n+        visited.add((nX, nY, k))\n \n-# Initialize the field as a dictionary\n-def initialize_field(file_path):\n-    field = {}\n-    max_row = 0\n-    max_col = 0\n-    with open(file_path) as file:\n-        for row_idx, line in enumerate(file):\n-            for col_idx, char in enumerate(line.rstrip('\\n')):\n-                if char == Symbols.FREE:\n-                    field[(row_idx, col_idx)] = []\n-                else:\n-                    field[(row_idx, col_idx)] = [char]\n-                max_col = max(max_col, col_idx)\n-            max_row = max(max_row, row_idx)\n-    return field, max_row, max_col\n+        nX += dirs[k][0]\n+        nY += dirs[k][1]\n \n-# Function to find the guard's initial position\n-def find_guard(field):\n-    for (row, col), symbols in field.items():\n-        if Symbols.GUARD in symbols:\n-            return row, col\n-    # If guard not found, set default position\n-    return 0, 0\n+        if not (0 <= nY < len(grid)) or not (0 <= nX < len(grid[0])):\n+            return False\n \n-# Animate Part 2 using terminal output with hashmap\n-def animate_part_2(guard_row, guard_col, facing, field, max_row, max_col, max_steps=10000):\n-    loop_count = 0\n-    detected_loops = set()  # To track unique loop states\n-    visited_states = {}     # To track when a state was first visited\n-    steps = 0               # Step counter to prevent infinite loops\n+loop_counted = 0\n+for y in range(len(grid)):\n+    for x in range(len(grid[0])):\n+        if grid[y][x] == \".\":\n+            if startpos == (x, y):\n+                continue\n \n-    while in_bounds(guard_row, guard_col, field, max_row, max_col) and steps < max_steps:\n-        steps += 1\n-        current_pos = (guard_row, guard_col)\n-        current_symbols = field.get(current_pos, [])\n-\n-        # Overwrite the current cell with the current facing direction\n-        if not current_symbols or Symbols.FREE in current_symbols:\n-            field[current_pos] = [getattr(Symbols, facing.name)]\n-        else:\n-            field[current_pos].append(getattr(Symbols, facing.name))\n-        \n-        # Clear the console\n-        os.system('cls' if os.name == 'nt' else 'clear')\n-        \n-        # Print the field\n-        for row in range(max_row + 1):\n-            row_str = ''\n-            for col in range(max_col + 1):\n-                cell_symbols = field.get((row, col), [])\n-                if not cell_symbols:\n-                    row_str += Symbols.FREE\n-                else:\n-                    # Display the most recent direction symbol\n-                    row_str += cell_symbols[-1]\n-            print(row_str)\n-        \n-        time.sleep(0.01)  # Adjust the sleep time as needed for visibility\n-        \n-        # Determine the next position\n-        new_row, new_col = move(guard_row, guard_col, facing)\n-        new_pos = (new_row, new_col)\n-        \n-        if not in_bounds(new_row, new_col, field, max_row, max_col):\n-            print(\"Guard has moved out of bounds.\")\n-            break\n-        \n-        split = field[new_pos]\n-        \n-        for symbol in split:\n-            match symbol:\n-                case Symbols.WALL:\n-                    facing = turn_right(facing)\n-                    break  # Stop processing symbols after hitting a wall\n-                case Symbols.FREE:\n-                    pass  # Continue moving forward\n-                case direction if direction in [Symbols.NORTH, Symbols.EAST, Symbols.SOUTH, Symbols.WEST]:\n-                    # Create a unique state identifier\n-                    state = (new_pos, facing)\n\\ No newline at end of file\n-                    if state in visited_states:\n-                        # Loop detected\n-                        if state not in detected_loops:\n-                            loop_count += 1\n-                            print(f\"Guard has entered a loop #{loop_count} at position {new_pos} facing {facing.name}.\")\n-                            detected_loops.add(state)\n-                    else:\n-                        visited_states[state] = True\n-                case _:\n-                    print('bug field = ' + str(field[new_pos]))\n-                    return loop_count  # Exit on unexpected symbol\n-        \n-        # Move the guard to the new position if no wall was encountered\n-        if Symbols.WALL not in split:\n-            guard_row, guard_col = new_row, new_col\n-            # Mark as visited (optional)\n-            if Symbols.VISITED not in field[new_pos]:\n-                field[new_pos].append(Symbols.VISITED)\n-    \n-    if steps >= max_steps:\n-        print(f\"Reached maximum steps ({max_steps}). Simulation terminated to prevent infinite loop.\")\n-    \n-    return loop_count\n-\n-# Main Execution\n-if __name__ == \"__main__\":\n-    # Initialize field from input file\n-    input_file = \"inputs/input_06.txt\"  # Replace with your actual input file path\n-    field, max_row, max_col = initialize_field(input_file)\n-    \n-    # Find the guard's initial position\n-    guard_row, guard_col = find_guard(field)\n-    facing = Direction.NORTH  # Initialize facing direction (adjust as needed)\n-    \n-    # Run the simulation\n-    loop_count = animate_part_2(guard_row, guard_col, facing, field, max_row, max_col)\n-    print(f\"Total loops detected: {loop_count}\")\n+            grid[y][x] = \"#\" \n+            if check_loop(grid):\n+                loop_counted += 1\n+            grid[y][x] = \".\"\n+print(loop_counted)     \n\\ No newline at end of file\n"
                },
                {
                    "date": 1733610266222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n from sys import stdin\n \n grid = []\n startpos = ()\n+open\n for line in stdin:\n     col = []\n     for x in line.strip():\n         if x == \"^\":\n"
                },
                {
                    "date": 1733610275599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from sys import stdin\n \n grid = []\n startpos = ()\n-open\n+with open\n for line in stdin:\n     col = []\n     for x in line.strip():\n         if x == \"^\":\n"
                },
                {
                    "date": 1733610281713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n from sys import stdin\n \n grid = []\n startpos = ()\n-with open\n+with open(\"inputs/input_06.txt\") as file:\n for line in stdin:\n     col = []\n     for x in line.strip():\n         if x == \"^\":\n"
                },
                {
                    "date": 1733610288958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,16 +2,17 @@\n \n grid = []\n startpos = ()\n with open(\"inputs/input_06.txt\") as file:\n-for line in stdin:\n-    col = []\n-    for x in line.strip():\n-        if x == \"^\":\n-            startpos = (line.index(x), len(grid))\n-        col.append(x)\n-    grid.append(col)\n+    for line in file:\n+        col = []\n+        for x in line.strip():\n+            if x == \"^\":\n+                startpos = (line.index(x), len(grid))\n+            col.append(x)\n+        grid.append(col)\n \n+\n dirs = [(0, -1), (1, 0), (0, 1), (-1, 0)]\n \n def check_loop(new_grid):\n     visited = set()\n"
                },
                {
                    "date": 1733610381092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n         nX += dirs[k][0]\n         nY += dirs[k][1]\n \n         if not (0 <= nY < len(grid)) or not (0 <= nX < len(grid[0])):\n-            return False\n+            return False, \n \n loop_counted = 0\n for y in range(len(grid)):\n     for x in range(len(grid[0])):\n"
                },
                {
                    "date": 1733610407979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,11 +23,9 @@\n         if new_grid[nY][nX] == \"#\":\n             nX -= dirs[k][0]\n             nY -= dirs[k][1]\n \n-            k += 1\n-            if k == 4:\n-                k = 0\n+            k = (k + 1) % 4\n \n         if (nX, nY, k) in visited:\n             return True\n     \n@@ -36,9 +34,9 @@\n         nX += dirs[k][0]\n         nY += dirs[k][1]\n \n         if not (0 <= nY < len(grid)) or not (0 <= nX < len(grid[0])):\n-            return False, \n+            return False, visited\n \n loop_counted = 0\n for y in range(len(grid)):\n     for x in range(len(grid[0])):\n"
                },
                {
                    "date": 1733610460159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,8 +37,9 @@\n         if not (0 <= nY < len(grid)) or not (0 <= nX < len(grid[0])):\n             return False, visited\n \n loop_counted = 0\n+\n for y in range(len(grid)):\n     for x in range(len(grid[0])):\n         if grid[y][x] == \".\":\n             if startpos == (x, y):\n"
                },
                {
                    "date": 1733610476206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n         if not (0 <= nY < len(grid)) or not (0 <= nX < len(grid[0])):\n             return False, visited\n \n loop_counted = 0\n-\n+guard \n for y in range(len(grid)):\n     for x in range(len(grid[0])):\n         if grid[y][x] == \".\":\n             if startpos == (x, y):\n"
                },
                {
                    "date": 1733610486410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n         if not (0 <= nY < len(grid)) or not (0 <= nX < len(grid[0])):\n             return False, visited\n \n loop_counted = 0\n-_, guard_\n+_, guard_visited = check_loop(grid)\n for y in range(len(grid)):\n     for x in range(len(grid[0])):\n         if grid[y][x] == \".\":\n             if startpos == (x, y):\n"
                },
                {
                    "date": 1733611580745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n # only check cells visited by the guard\n for x, y, _ in guard_visited:\n     grid[y][x] = \"#\"\n     res, _ = check_loop(grid)\n-    \n+    if res:\n         loop_counted += 1\n     grid[y][x] = \".\"\n \n # for y in range(len(grid)):\n"
                }
            ],
            "date": 1733602139611,
            "name": "Commit-0",
            "content": "from enum import IntEnum\nimport time\nimport os\n\n# Define Directions using IntEnum for clarity\nclass Direction(IntEnum):\n    NORTH = 0\n    EAST = 1\n    SOUTH = 2\n    WEST = 3\n\n# Define Symbols for representation\nclass Symbols:\n    GUARD = '^'\n    WALL = '#'\n    FREE = '.'\n    VISITED = 'x'\n    NORTH = 'N'\n    EAST = 'E'\n    SOUTH = 'S'\n    WEST = 'W'\n\n# Movement function based on current direction\ndef move(row, col, direction):\n    match direction:\n        case Direction.NORTH:\n            return row - 1, col\n        case Direction.SOUTH:\n            return row + 1, col\n        case Direction.WEST:\n            return row, col - 1\n        case Direction.EAST:\n            return row, col + 1\n\n# Boundary check to ensure the guard stays within the field\ndef in_bounds(row, col, field):\n    return (row, col) in field\n\n# Function to turn the guard right\ndef turn_right(facing):\n    return Direction((facing + 1) % 4)\n\n# Initialize the field as a dictionary\ndef initialize_field(file_path):\n    field = {}\n    max_row = 0\n    max_col = 0\n    with open(file_path) as file:\n        for row_idx, line in enumerate(file):\n            for col_idx, char in enumerate(line.rstrip('\\n')):\n                field[(row_idx, col_idx)] = char\n                max_col = max(max_col, col_idx)\n            max_row = max(max_row, row_idx)\n    return field, max_row, max_col\n\n# Function to find the guard's initial position\ndef find_guard(field):\n    for (row, col), symbol in field.items():\n        if symbol == Symbols.GUARD:\n            return row, col\n    # If guard not found, set default position\n    return 0, 0\n\n# Animate Part 2 using terminal output with hashmap\ndef animate_part_2(guard_row, guard_col, facing, field, max_row, max_col):\n    loop_count = 0\n    while in_bounds(guard_row, guard_col, field):\n        current_pos = (guard_row, guard_col)\n        current_symbol = field.get(current_pos, Symbols.FREE)\n        \n        # Overwrite the current cell with the facing direction\n        if current_symbol == Symbols.FREE or current_symbol == Symbols.VISITED:\n            field[current_pos] = getattr(Symbols, facing.name)\n        else:\n            field[current_pos] = getattr(Symbols, facing.name)\n        \n        # Clear the console\n        os.system('cls' if os.name == 'nt' else 'clear')\n        \n        # Print the field\n        for row in range(max_row + 1):\n            row_str = ''\n            for col in range(max_col + 1):\n                row_str += field.get((row, col), Symbols.FREE)\n            print(row_str)\n        \n        time.sleep(0.2)\n        \n        # Determine the next position\n        new_row, new_col = move(guard_row, guard_col, facing)\n        new_pos = (new_row, new_col)\n        \n        if not in_bounds(new_row, new_col, field):\n            print(\"Guard has moved out of bounds.\")\n            break\n        \n        split = field[new_pos].split(',')\n        \n        for symbol in split:\n            match symbol:\n                case Symbols.WALL:\n                    facing = turn_right(facing)\n                    break  # Stop processing symbols after hitting a wall\n                case Symbols.FREE:\n                    pass  # Continue moving forward\n                case direction if direction in [Symbols.NORTH, Symbols.EAST, Symbols.SOUTH, Symbols.WEST]:\n                    # Handle loop detection based on current facing and symbol\n                    if (facing == Direction.WEST and direction == Symbols.NORTH) or \\\n                       (facing == Direction.NORTH and direction == Symbols.EAST) or \\\n                       (facing == Direction.EAST and direction == Symbols.SOUTH) or \\\n                       (facing == Direction.SOUTH and direction == Symbols.WEST):\n                        loop_count += 1\n                        print(\"Guard is stuck in a loop!\")\n                        return loop_count\n                case _:\n                    print('bug field = ' + str(field[new_pos]))\n                    return loop_count  # Exit on unexpected symbol\n        \n        # Move the guard to the new position if no wall was encountered\n        if Symbols.WALL not in split:\n            guard_row, guard_col = new_row, new_col\n            field[new_pos] = Symbols.VISITED  # Mark as visited\n\n    return loop_count\n\n# Main Execution\nif __name__ == \"__main__\":\n    # Initialize field from input file\n    input_file = \"inputs/input_06.txt\"  # Replace with your actual input file path\n    field, max_row, max_col = initialize_field(input_file)\n    \n    # Find the guard's initial position\n    guard_row, guard_col = find_guard(field)\n    facing = Direction.NORTH  # Initialize facing direction (adjust as needed)\n    \n    # Run the simulation\n    loop_count = animate_part_2(guard_row, guard_col, facing, field, max_row, max_col)\n    print(f\"Guard loop count: {loop_count}\")"
        }
    ]
}