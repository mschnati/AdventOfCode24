{
    "sourceFile": "g.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 20,
            "patches": [
                {
                    "date": 1733603749732,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1733603766651,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,79 @@\n-def read_map_from_file(filename):\n-    \"\"\"Reads the map from a file.\n+def simulate_guard(map, start_pos, start_dir):\n+    \"\"\"Simulates the guard's movement on the map.\n \n     Args:\n-        filename: The name of the file containing the map.\n+        map: A 2D list representing the map.\n+        start_pos: The starting position of the guard as a tuple (row, col).\n+        start_dir: The starting direction of the guard as a string ('^', 'v', '<', '>').\n \n     Returns:\n-        A 2D list representing the map.\n+        A set of visited positions.\n     \"\"\"\n \n-    with open(filename, 'r') as f:\n-        lines = f.readlines()\n-    return [list(line.strip()) for line in lines]\n+    directions = ['^', '>', 'v', '<']\n+    dir_index = directions.index(start_dir)\n\\ No newline at end of file\n+    pos = start_pos\n+    visited = set()\n+    visited.add(pos)\n \n-# ... rest of the code\n+    while True:\n+        row, col = pos\n+        if map[row][col] == '#':\n+            dir_index = (dir_index + 1) % 4\n+        else:\n+            if directions[dir_index] == '^':\n+                row -= 1\n+            elif directions[dir_index] == '>':\n+                col += 1\n+            elif directions[dir_index] == 'v':\n+                row += 1\n+            else:\n+                col -= 1\n+            pos = (row, col)\n+            if pos in visited:\n+                return visited\n+            visited.add(pos)\n \n-# Read the map from a file\n-filename = 'map.txt'  # Replace with your actual filename\n-map = read_map_from_file(filename)\n+def count_looping_positions(map, start_pos, start_dir):\n+    \"\"\"Counts the number of positions where adding an obstruction creates a loop.\n \n-# ... rest of the code\n+    Args:\n+        map: A 2D list representing the map.\n+        start_pos: The starting position of the guard as a tuple (row, col).\n+        start_dir: The starting direction of the guard as a string ('^', 'v', '<', '>').\n+\n+    Returns:\n+        The number of looping positions.\n+    \"\"\"\n+\n+    count = 0\n+    for row in range(len(map)):\n+        for col in range(len(map[0])):\n+            if (row, col) == start_pos:\n+                continue\n+            new_map = [list(row) for row in map]\n+            new_map[row][col] = '#'\n+            visited = simulate_guard(new_map, start_pos, start_dir)\n+            if len(visited) < len(map) * len(map[0]):\n+                count += 1\n+    return count\n+\n+# Assuming you have the map data in a suitable format (e.g., a list of strings)\n+map_data = [\n+    # ... your map data here ...\n+]\n+\n+# Parse the map data into a 2D list\n+map = [list(row) for row in map_data]\n+\n+# Find the starting position and direction of the guard\n+for row in range(len(map)):\n+    for col in range(len(map[0])):\n+        if map[row][col] in ['^', 'v', '<', '>']:\n+            start_pos = (row, col)\n+            start_dir = map[row][col]\n+            map[row][col] = '.'  # Replace the guard symbol with '.'\n+\n+# Count the looping positions\n+result = count_looping_positions(map, start_pos, start_dir)\n+print(result)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733603776290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+\n+\n def simulate_guard(map, start_pos, start_dir):\n     \"\"\"Simulates the guard's movement on the map.\n \n     Args:\n"
                },
                {
                    "date": 1733603801788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,18 @@\n+def read_map_from_file(filename):\n+    \"\"\"Reads the map from a file.\n \n+    Args:\n+        filename: The name of the file containing the map.\n \n+    Returns:\n+        A 2D list representing the map.\n+    \"\"\"\n+\n+    with open(filename, 'r') as f:\n+        lines = f.readlines()\n+    return [list(line.strip()) for line in lines]\n+\n def simulate_guard(map, start_pos, start_dir):\n     \"\"\"Simulates the guard's movement on the map.\n \n     Args:\n@@ -59,13 +71,11 @@\n             if len(visited) < len(map) * len(map[0]):\n                 count += 1\n     return count\n \n-# Assuming you have the map data in a suitable format (e.g., a list of strings)\n-map_data = [\n-    # ... your map data here ...\n-]\n-\n+# Read the map from a file\n+filename = 'map.txt'  # Replace with your actual filename\n+map = read_map_from_file(filename)\n # Parse the map data into a 2D list\n map = [list(row) for row in map_data]\n \n # Find the starting position and direction of the guard\n"
                },
                {
                    "date": 1733603808711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,9 @@\n                 count += 1\n     return count\n \n # Read the map from a file\n-filename = 'map.txt'  # Replace with your actual filename\n+filename = ''  # Replace with your actual filename\n map = read_map_from_file(filename)\n # Parse the map data into a 2D list\n map = [list(row) for row in map_data]\n \n"
                },
                {
                    "date": 1733603813856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,9 @@\n                 count += 1\n     return count\n \n # Read the map from a file\n-filename = ''  # Replace with your actual filename\n+filename = 'inputs/input_06.txt'  # Replace with your actual filename\n map = read_map_from_file(filename)\n # Parse the map data into a 2D list\n map = [list(row) for row in map_data]\n \n"
                },
                {
                    "date": 1733603820125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,11 +74,10 @@\n \n # Read the map from a file\n filename = 'inputs/input_06.txt'  # Replace with your actual filename\n map = read_map_from_file(filename)\n-# Parse the map data into a 2D list\n-map = [list(row) for row in map_data]\n \n+\n # Find the starting position and direction of the guard\n for row in range(len(map)):\n     for col in range(len(map[0])):\n         if map[row][col] in ['^', 'v', '<', '>']:\n"
                },
                {
                    "date": 1733604188581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,18 +11,18 @@\n     with open(filename, 'r') as f:\n         lines = f.readlines()\n     return [list(line.strip()) for line in lines]\n \n-def simulate_guard(map, start_pos, start_dir):\n-    \"\"\"Simulates the guard's movement on the map.\n+def simulate_guard_path(map, start_pos, start_dir):\n+    \"\"\"Simulates the guard's path without placing obstacles.\n \n     Args:\n         map: A 2D list representing the map.\n         start_pos: The starting position of the guard as a tuple (row, col).\n         start_dir: The starting direction of the guard as a string ('^', 'v', '<', '>').\n \n     Returns:\n-        A set of visited positions.\n+        A set of positions the guard would visit.\n     \"\"\"\n \n     directions = ['^', '>', 'v', '<']\n     dir_index = directions.index(start_dir)\n@@ -44,33 +44,29 @@\n             else:\n                 col -= 1\n             pos = (row, col)\n             if pos in visited:\n-                return visited\n+                break\n             visited.add(pos)\n \n-def count_looping_positions(map, start_pos, start_dir):\n-    \"\"\"Counts the number of positions where adding an obstruction creates a loop.\n+    return visited\n \n+def count_looping_positions(visited_positions):\n+    \"\"\"Counts the number of looping positions.\n+\n     Args:\n-        map: A 2D list representing the map.\n-        start_pos: The starting position of the guard as a tuple (row, col).\n-        start_dir: The starting direction of the guard as a string ('^', 'v', '<', '>').\n+        visited_positions: A set of positions the guard would visit.\n \n     Returns:\n         The number of looping positions.\n     \"\"\"\n \n     count = 0\n-    for row in range(len(map)):\n-        for col in range(len(map[0])):\n-            if (row, col) == start_pos:\n-                continue\n-            new_map = [list(row) for row in map]\n-            new_map[row][col] = '#'\n-            visited = simulate_guard(new_map, start_pos, start_dir)\n-            if len(visited) < len(map) * len(map[0]):\n-                count += 1\n+    for pos in visited_positions:\n+        new_visited = simulate_guard_path(map, start_pos, start_dir)\n+        if pos in new_visited:\n+            count += 1\n+\n     return count\n \n # Read the map from a file\n filename = 'inputs/input_06.txt'  # Replace with your actual filename\n"
                },
                {
                    "date": 1733604214264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,7 +80,10 @@\n             start_pos = (row, col)\n             start_dir = map[row][col]\n             map[row][col] = '.'  # Replace the guard symbol with '.'\n \n+# Simulate the guard's path without obstacles\n+visited_positions = simulate_guard_path(map, start_pos, start_dir)\n+\n # Count the looping positions\n-result = count_looping_positions(map, start_pos, start_dir)\n+result = count_looping_positions(visited_positions)\n print(result)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733604468325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,24 +31,29 @@\n     visited.add(pos)\n \n     while True:\n         row, col = pos\n-        if map[row][col] == '#':\n-            dir_index = (dir_index + 1) % 4\n+        next_row, next_col = row, col\n+\n+        if directions[dir_index] == '^':\n+            next_row -= 1\n+        elif directions[dir_index] == '>':\n+            next_col += 1\n+        elif directions[dir_index] == 'v':\n+            next_row += 1\n         else:\n-            if directions[dir_index] == '^':\n-                row -= 1\n-            elif directions[dir_index] == '>':\n-                col += 1\n-            elif directions[dir_index] == 'v':\n-                row += 1\n-            else:\n-                col -= 1\n-            pos = (row, col)\n-            if pos in visited:\n-                break\n-            visited.add(pos)\n+            next_col -= 1\n \n+        if 0 <= next_row < len(map) and 0 <= next_col < len(map[0]) and map[next_row][next_col] != '#':\n+            row, col = next_row, next_col\n+        else:\n+            dir_index = (dir_index + 1) % 4\n+\n+        pos = (row, col)\n+        if pos in visited:\n+            break\n+        visited.add(pos)\n+\n     return visited\n \n def count_looping_positions(visited_positions):\n     \"\"\"Counts the number of looping positions.\n"
                },
                {
                    "date": 1733604502699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,8 +65,9 @@\n         The number of looping positions.\n     \"\"\"\n \n     count = 0\n+    print(visited_positions)\n     for pos in visited_positions:\n         new_visited = simulate_guard_path(map, start_pos, start_dir)\n         if pos in new_visited:\n             count += 1\n"
                },
                {
                    "date": 1733604714557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n         start_pos: The starting position of the guard as a tuple (row, col).\n         start_dir: The starting direction of the guard as a string ('^', 'v', '<', '>').\n \n     Returns:\n-        A set of positions the guard would visit.\n+        A set of positions the guard would visit and a boolean indicating if a loop was found.\n     \"\"\"\n \n     directions = ['^', '>', 'v', '<']\n     dir_index = directions.index(start_dir)\n@@ -44,17 +44,23 @@\n             next_col -= 1\n \n         if 0 <= next_row < len(map) and 0 <= next_col < len(map[0]) and map[next_row][next_col] != '#':\n             row, col = next_row, next_col\n+            visited.add(pos)\n         else:\n+            # Check if the guard is about to walk out of the map\n+            if not (0 <= next_row < len(map) and 0 <= next_col < len(map[0])):\n+                return visited, False\n+\n+            # Check for a loop: same position, same direction\n+            if pos in visited and directions[dir_index] == start_dir:\n+                return visited, True\n+\n             dir_index = (dir_index + 1) % 4\n \n         pos = (row, col)\n-        if pos in visited:\n-            break\n-        visited.add(pos)\n \n-    return visited\n+    return visited, False\n \n def count_looping_positions(visited_positions):\n     \"\"\"Counts the number of looping positions.\n \n"
                },
                {
                    "date": 1733604731041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,9 +93,12 @@\n             start_dir = map[row][col]\n             map[row][col] = '.'  # Replace the guard symbol with '.'\n \n # Simulate the guard's path without obstacles\n-visited_positions = simulate_guard_path(map, start_pos, start_dir)\n+visited_positions, has_loop = simulate_guard_path(map, start_pos, start_dir)\n \n-# Count the looping positions\n-result = count_looping_positions(visited_positions)\n\\ No newline at end of file\n-print(result)\n+if has_loop:\n+    # Count the looping positions as before\n+    result = count_looping_positions(visited_positions)\n+    print(result)\n+else:\n+    print(\"No loop found.\")\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733604831265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,57 +11,58 @@\n     with open(filename, 'r') as f:\n         lines = f.readlines()\n     return [list(line.strip()) for line in lines]\n \n-def simulate_guard_path(map, start_pos, start_dir):\n-    \"\"\"Simulates the guard's path without placing obstacles.\n+def simulate_guard_path(map, start_pos, start_dir, visited):\n+    \"\"\"Simulates the guard's path with all possible right turns.\n \n     Args:\n         map: A 2D list representing the map.\n         start_pos: The starting position of the guard as a tuple (row, col).\n         start_dir: The starting direction of the guard as a string ('^', 'v', '<', '>').\n+        visited: A set to keep track of visited positions.\n \n     Returns:\n-        A set of positions the guard would visit and a boolean indicating if a loop was found.\n+        A list of sets, each set representing a loop.\n     \"\"\"\n \n     directions = ['^', '>', 'v', '<']\n     dir_index = directions.index(start_dir)\n-    pos = start_pos\n-    visited = set()\n-    visited.add(pos)\n+    row, col = start_pos\n \n-    while True:\n-        row, col = pos\n-        next_row, next_col = row, col\n+    # Check if the guard is about to walk out of the map\n+    if not (0 <= row < len(map) and 0 <= col < len(map[0])):\n+        return []\n \n-        if directions[dir_index] == '^':\n-            next_row -= 1\n-        elif directions[dir_index] == '>':\n-            next_col += 1\n-        elif directions[dir_index] == 'v':\n-            next_row += 1\n-        else:\n-            next_col -= 1\n+    # Check if the guard is about to walk into a wall\n+    if map[row][col] == '#':\n+        return []\n \n-        if 0 <= next_row < len(map) and 0 <= next_col < len(map[0]) and map[next_row][next_col] != '#':\n-            row, col = next_row, next_col\n-            visited.add(pos)\n-        else:\n-            # Check if the guard is about to walk out of the map\n-            if not (0 <= next_row < len(map) and 0 <= next_col < len(map[0])):\n-                return visited, False\n+    # Check if the guard is entering a loop\n+    if (row, col, dir_index) in visited:\n+        return [(row, col)]\n \n-            # Check for a loop: same position, same direction\n-            if pos in visited and directions[dir_index] == start_dir:\n-                return visited, True\n+    visited.add((row, col, dir_index))\n \n-            dir_index = (dir_index + 1) % 4\n+    # Try moving straight\n+    next_row, next_col = row, col\n+    if directions[dir_index] == '^':\n+        next_row -= 1\n+    elif directions[dir_index] == '>':\n+        next_col += 1\n+    elif directions[dir_index] == 'v':\n+        next_row += 1\n+    else:\n+        next_col -= 1\n \n-        pos = (row, col)\n+    straight_loops = simulate_guard_path(map, (next_row, next_col), directions[dir_index], visited.copy())\n \n-    return visited, False\n+    # Try turning right\n+    dir_index = (dir_index + 1) % 4\n+    right_turn_loops = simulate_guard_path(map, (row, col), directions[dir_index], visited.copy())\n \n+    return straight_loops + right_turn_loops\n+\n def count_looping_positions(visited_positions):\n     \"\"\"Counts the number of looping positions.\n \n     Args:\n"
                },
                {
                    "date": 1733604848417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -93,13 +93,10 @@\n             start_pos = (row, col)\n             start_dir = map[row][col]\n             map[row][col] = '.'  # Replace the guard symbol with '.'\n \n-# Simulate the guard's path without obstacles\n-visited_positions, has_loop = simulate_guard_path(map, start_pos, start_dir)\n+# Simulate all possible paths\n+all_loops = simulate_guard_path(map, start_pos, start_dir, set())\n \n-if has_loop:\n-    # Count the looping positions as before\n-    result = count_looping_positions(visited_positions)\n-    print(result)\n\\ No newline at end of file\n-else:\n-    print(\"No loop found.\")\n+# Count the number of unique loops\n+unique_loops = set(tuple(loop) for loop in all_loops)\n+print(len(unique_loops))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733604917752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,58 +11,65 @@\n     with open(filename, 'r') as f:\n         lines = f.readlines()\n     return [list(line.strip()) for line in lines]\n \n-def simulate_guard_path(map, start_pos, start_dir, visited):\n-    \"\"\"Simulates the guard's path with all possible right turns.\n+from collections import deque\n \n+def simulate_guard_paths(map, start_pos, start_dir):\n+    \"\"\"Simulates all possible guard paths using BFS.\n+\n     Args:\n         map: A 2D list representing the map.\n         start_pos: The starting position of the guard as a tuple (row, col).\n         start_dir: The starting direction of the guard as a string ('^', 'v', '<', '>').\n-        visited: A set to keep track of visited positions.\n \n     Returns:\n-        A list of sets, each set representing a loop.\n+        A set of tuples representing unique loops.\n     \"\"\"\n \n     directions = ['^', '>', 'v', '<']\n-    dir_index = directions.index(start_dir)\n-    row, col = start_pos\n+    queue = deque([(start_pos, start_dir)])\n+    visited = set()\n+    loops = set()\n \n-    # Check if the guard is about to walk out of the map\n-    if not (0 <= row < len(map) and 0 <= col < len(map[0])):\n-        return []\n+    while queue:\n+        pos, dir_index = queue.popleft()\n+        row, col = pos\n \n-    # Check if the guard is about to walk into a wall\n-    if map[row][col] == '#':\n-        return []\n+        # Check if the guard is about to walk out of the map\n+        if not (0 <= row < len(map) and 0 <= col < len(map[0])):\n+            continue\n \n-    # Check if the guard is entering a loop\n-    if (row, col, dir_index) in visited:\n-        return [(row, col)]\n+        # Check if the guard is about to walk into a wall\n+        if map[row][col] == '#':\n+            continue\n \n-    visited.add((row, col, dir_index))\n+        # Check if the guard is entering a loop\n+        if (row, col, dir_index) in visited:\n+            loops.add((row, col))\n+            continue\n \n-    # Try moving straight\n-    next_row, next_col = row, col\n-    if directions[dir_index] == '^':\n-        next_row -= 1\n-    elif directions[dir_index] == '>':\n-        next_col += 1\n-    elif directions[dir_index] == 'v':\n-        next_row += 1\n-    else:\n-        next_col -= 1\n+        visited.add((row, col, dir_index))\n \n-    straight_loops = simulate_guard_path(map, (next_row, next_col), directions[dir_index], visited.copy())\n+        # Try moving straight\n+        next_row, next_col = row, col\n+        if directions[dir_index] == '^':\n+            next_row -= 1\n+        elif directions[dir_index] == '>':\n+            next_col += 1\n+        elif directions[dir_index] == 'v':\n+            next_row += 1\n+        else:\n+            next_col -= 1\n \n-    # Try turning right\n-    dir_index = (dir_index + 1) % 4\n-    right_turn_loops = simulate_guard_path(map, (row, col), directions[dir_index], visited.copy())\n+        queue.append(((next_row, next_col), dir_index))\n \n-    return straight_loops + right_turn_loops\n+        # Try turning right\n+        dir_index = (dir_index + 1) % 4\n+        queue.append(((row, col), dir_index))\n \n+    return loops\n+\n def count_looping_positions(visited_positions):\n     \"\"\"Counts the number of looping positions.\n \n     Args:\n"
                },
                {
                    "date": 1733604935249,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,27 +68,8 @@\n         queue.append(((row, col), dir_index))\n \n     return loops\n \n-def count_looping_positions(visited_positions):\n-    \"\"\"Counts the number of looping positions.\n-\n-    Args:\n-        visited_positions: A set of positions the guard would visit.\n-\n-    Returns:\n-        The number of looping positions.\n-    \"\"\"\n-\n-    count = 0\n-    print(visited_positions)\n-    for pos in visited_positions:\n-        new_visited = simulate_guard_path(map, start_pos, start_dir)\n-        if pos in new_visited:\n-            count += 1\n-\n-    return count\n-\n # Read the map from a file\n filename = 'inputs/input_06.txt'  # Replace with your actual filename\n map = read_map_from_file(filename)\n \n"
                },
                {
                    "date": 1733604943181,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,6 @@\n             start_dir = map[row][col]\n             map[row][col] = '.'  # Replace the guard symbol with '.'\n \n # Simulate all possible paths\n-all_loops = simulate_guard_path(map, start_pos, start_dir, set())\n-\n-# Count the number of unique loops\n-unique_loops = set(tuple(loop) for loop in all_loops)\n-print(len(unique_loops))\n\\ No newline at end of file\n+all_loops = simulate_guard_paths(map, start_pos, start_dir)\n+print(len(all_loops))\n\\ No newline at end of file\n"
                },
                {
                    "date": 1733604986819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n \n # Find the starting position and direction of the guard\n for row in range(len(map)):\n     for col in range(len(map[0])):\n-        if map[row][col] in ['^', 'v', '<', '>']:\n+        if map[row][col] is \n             start_pos = (row, col)\n             start_dir = map[row][col]\n             map[row][col] = '.'  # Replace the guard symbol with '.'\n \n"
                },
                {
                    "date": 1733604991918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,9 +76,9 @@\n \n # Find the starting position and direction of the guard\n for row in range(len(map)):\n     for col in range(len(map[0])):\n-        if map[row][col] is ''\n+        if map[row][col] is '^'\n             start_pos = (row, col)\n             start_dir = map[row][col]\n             map[row][col] = '.'  # Replace the guard symbol with '.'\n \n"
                },
                {
                    "date": 1733608292462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,9 +133,9 @@\n # with Pool() as pool:\n #     results = pool.starmap(can_create_loop, [(map, start_pos, pos) for pos in first_walk_positions])\n \n # Serial version\n-results = [can_create_loop(map, start_pos, pos) for pos in first_walk_positions]\n+results = [can_create_loop(gamemap, start_pos, pos) for pos in first_walk_positions]\n \n # Count the number of positions where a loop can be created\n loop_count = sum(results)\n print(loop_count)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1733603749732,
            "name": "Commit-0",
            "content": "def read_map_from_file(filename):\n    \"\"\"Reads the map from a file.\n\n    Args:\n        filename: The name of the file containing the map.\n\n    Returns:\n        A 2D list representing the map.\n    \"\"\"\n\n    with open(filename, 'r') as f:\n        lines = f.readlines()\n    return [list(line.strip()) for line in lines]\n\n# ... rest of the code\n\n# Read the map from a file\nfilename = 'map.txt'  # Replace with your actual filename\nmap = read_map_from_file(filename)\n\n# ... rest of the code"
        }
    ]
}